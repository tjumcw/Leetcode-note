# 图

- 图通常分为有向或无向，有 循环或无循环，所有节点相连或不相连。
- 树即是 一个相连的无向无环图，而另一种很常见的图是有向无环图（Directed Acyclic Graph，DAG）。

![image-20220730193509021](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220730193509021.png)



### 一、图的表示方式

假设假设图中一共有 n 个节点、m 条边。

#### 1、邻接矩阵

- 建立一个 n× n 的矩阵 G，如果第 i 个节点连向第 j 个节点，则 G（i，j）= 1，反之为 0
- 如果图是无向的，则这个矩阵一定是对称矩阵，即G（i，j）= G（j，i）

#### 2、邻接链表

- 建立一个大小为 n 的数组，每个位置 i 储存一个数组 或者链表，表示第 i 个节点连向的其它节点。

其中，邻接矩阵空间开销比邻接链表大，但是邻接链表不 支持快速查找 i 和 j 是否相连。



### 二、Leetcode例题

#### 785、判断二分图

- 利用队列和bfs，我们可以对未染色的节点进行染色，并且检查是否有颜色相同的相邻节点存在。

- 其中，color[i] = -1表示未染色，0表示第一种颜色，1表示第二种颜色

```c++
class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
        set<int> s;
        int n = graph.size();
        queue<int> q;
        vector<int> color(n, -1);
        for(int i = 0; i < n; i++){
            if(color[i] == -1){
                q.push(i);
                color[i] = 0;
            }
            while(!q.empty()){
                int node = q.front();
                q.pop();
                for(auto idx : graph[node]){
                    if(color[idx] == -1){
                        q.push(idx);
                        color[idx] = color[node] == 0 ? 1 : 0;
                    }else{
                        if(color[idx] == color[node]){
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
};
```



### 三、拓扑排序

- 拓扑排序是一种常见的，对有向无环图排序的算法。
- 给定有向无环图中的 N 个节点，我们把它们排序成一个线性序列；若原图中节点 i 指向节点 j，则排序结果中 i 一定在 j 之前。
- 拓扑排序的结果不是唯一的，只要满足以上条件即可。



#### 例题：

**Leetcode 210**

- 我们使用一个队列来进行广度优先搜索。
- 开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。
- 在广度优先搜索的每一步中，我们取出队首的节点 u：
  - 我们将 u 放入答案中；
  - 我们移除 u 的所有出边，也就是将 uu 的所有相邻节点的入度减少 1。
  - 如果某个相邻节点 v的入度变为0，那么我们就将 v 放入队列中。
- 在广度优先搜索的过程结束后。如果答案中包含了这 n个节点，所有课程入度都为0（无环），即找到了一种拓扑排序

```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> matrix(numCourses, vector<int>());
        vector<int> inDgree(numCourses);
        for(auto vec : prerequisites){
            matrix[vec[1]].push_back(vec[0]);
            inDgree[vec[0]]++;
        }
        queue<int> q;
        for(int i = 0; i < numCourses; i++){
            if(!inDgree[i]){
                q.push(i);
            }
        }
        vector<int> ans;
        while(!q.empty()){
            int node = q.front();
            q.pop();
            ans.push_back(node);
            for(auto num : matrix[node]){
                inDgree[num]--;
                if(!inDgree[num]){
                    q.push(num);
                }
            }
        }
        return accumulate(inDgree.begin(), inDgree.end(), 0) == 0 ? ans : vector<int>();
    }
};
```

