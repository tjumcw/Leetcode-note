## 数据结构

### 前缀树

#### 208、实现Trie（前缀树）

```c++
class Trie {
public:
    struct Node{
        bool isEnd;
        struct Node* next[26];		//理解为二叉树的分叉变成了二十六叉
    };
    struct Node* root;
    Trie() {
        root = new Node();
    }
    
    void insert(string word) {
        struct Node* tmp = root;
        for(int i = 0; i < word.size(); i++){
            if(!tmp->next[word[i] - 'a']){
                tmp->next[word[i] - 'a'] = new Node();
            }
            tmp = tmp->next[word[i] - 'a'];
            if(i == word.size() - 1){
                tmp->isEnd = true;
            }
        }
    }
    
    bool search(string word) {
        struct Node* tmp = root;
        for(int i = 0; i < word.size(); i++){
            if(!tmp->next[word[i] - 'a']) return false;
            tmp = tmp->next[word[i] - 'a'];
            if(i == word.size() - 1){
                if(tmp->isEnd) return true;
                return false;
            }
        }
        return true;
    }
    
    bool startsWith(string prefix) {
        struct Node* tmp = root;
        for(int i = 0; i < prefix.size(); i++){
            if(!tmp->next[prefix[i] - 'a']) return false;
            tmp = tmp->next[prefix[i] - 'a'];
        }
        return true;
    }
};
```



#### 745、前缀和后缀搜索

- 借鉴了参考答案，使用了前缀树和另一个反向开始的前缀树（模拟后缀）

```c++
class WordFilter {
public:
    struct Node{
        vector<int> idxs;
        struct Node* next[26];
    };
    struct Node *pre = new Node(), *post = new Node();

    void insert(Node* node, const string& str, int idx, bool isTurn){
        int n = str.size();
        node->idxs.push_back(idx);
        for(int i = isTurn ? n - 1 : 0; i >= 0 & i < n; i += isTurn ? -1 : 1){
            if(!node->next[str[i] - 'a']){
                node->next[str[i] - 'a'] = new Node();
            }
            node = node->next[str[i] - 'a'];
            node->idxs.push_back(idx);
        }
    }

    int query(const string& a, const string& b){
        int m = a.size(), n = b.size();
        Node* tmp = pre;
        for(int i = 0; i < m; i++){
            if(!tmp->next[a[i] - 'a']) return -1;
            tmp = tmp->next[a[i] - 'a'];
        }
        vector<int>& l1 = tmp->idxs;
        tmp = post;
        for(int i = n - 1; i >= 0; i--){
            if(!tmp->next[b[i] - 'a']) return -1;
            tmp = tmp->next[b[i] - 'a'];
        }
        vector<int>& l2 = tmp->idxs;
        m = l1.size(), n = l2.size();
        for(int i = m - 1, j = n - 1; i >= 0 && j >= 0;){
            if(l1[i] > l2[j]) i--;
            else if(l1[i] < l2[j]) j--;
            else return l1[i];
        }
        return -1;
    }

    WordFilter(vector<string>& words) {
        for(int i = 0; i < words.size(); i++){
            insert(pre, words[i], i, false);
            insert(post, words[i], i, true);
        }
    }
    
    int f(string pref, string suff) {
        return query(pref, suff);
    }
};
```

- 其中vector<int>& l1 = tmp->idxs;和vector<int>& l2 = tmp->idxs;不用引用会超时