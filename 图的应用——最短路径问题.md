# 图的应用

## 一、最小生成树

原理：[最小生成树（普里姆算法和克鲁斯卡尔算法）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV19h411Q7Fu?spm_id_from=333.999.0.0&vd_source=8de202879dcd70a5bed8b07da0ce64f0)

### 生成树的概念

![image-20220731144129036](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220731144129036.png)

- 关键在于包含原图的全部顶点以及n - 1条边（n为顶点个数）
  - 边少一条就不是连通图（所有节点并不是全连通的）
  - 边多一条就形成了回路



### 最小生成树概念

![image-20220731144343813](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220731144343813.png)

### Prim（普里姆）算法

- 从任意顶点开始构建生成树
- 然后依次将当前已构建的节点连接的代价最小的节点纳入生成树
  - 比如开始先选冰冰纳入生成树
  - 最小代价为2，将对应的幂幂纳入生成树
  - 接着最小代价为4，对应冰冰和幂幂到西门的路径，任意选一条即可（最小生成树不唯一，但最小代价唯一）
- 直到所有节点都纳入（生成的最小生成树不唯一，但所有最小生成树的代价都相同，为最小代价）



### Kruskal（克鲁斯卡尔）算法

- 每次选择一条权值最小的边，让这条边两端的节点连通，若这两个节点已连通，则不选
  - 一开始最小权值为1，连通西门和苍井
  - 之后最小权值为2，连通冰冰和幂幂
  - 然后最小权值为3，连通金莲和王婆
  - 接下来最小代价为4，对应冰冰到西门以及幂幂到西门，任意连通如冰冰到西门
  - 再之后最小代价仍为4，为幂幂到西门，但他们通过冰冰已经连通了，不选
  - 发现不选该边后剩下的最小代价为5，但幂幂和苍井通过西门连通了，不选，连通西门和王婆
  - 到此为止所有点都连通了
- 其中判断连通性需要利用并查集



### 算法对比

![image-20220731150028975](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220731150028975.png)



## 二、最短路径问题

原理：[最短路径算法（BFS、Dijkstra、Floyd）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yy4y187QK?spm_id_from=333.999.0.0&vd_source=8de202879dcd70a5bed8b07da0ce64f0)

最短路径的应用主要有两种

- 单源最短路径：从某顶点出发，到其他全部顶点的最短路径
- 顶点间的最短路径：全部顶点（每对）之间的最短路径



最短路径的结果也有两种；

- 顶点之间最短序列从长度
- 从源顶点要目的顶点之间的路径（途径顶点的序列）



![image](https://user-images.githubusercontent.com/106053649/180795715-6065bc42-8b80-43a4-8438-9572e8c8e844.png)

其中，有几个注意点：

- Dijkstra算法也可用于求顶点间最短路径，需要额外一重for循环（时间复杂度高）
- Dijkstra算法的权值不能为负数



### BFS求无权图的单源最短路径
![image](https://user-images.githubusercontent.com/106053649/180816385-f69613f3-a725-43a8-8081-26ce0751a855.png)



- 利用bfs求最短路径，需要有3个辅助数组，我合并成了一个二维数组
- 其中，stat数组，对每个元素stat[i]，其三个元素分别为最短路径，前驱节点以及是否已访问
- 主要思想如下：
  - 首先初始化入口节点相关的值，其最短路径为0，前驱节点为-1，标记为已访问，将其加入队列
  - 进入while循环直到队列为空（都visit完后就不会push节点进去了）
  - 针对队列的首元素（最先进队列），对其邻接矩阵进行搜索，若其邻接矩阵为1的元素且未访问过，对其
    - 将其最短路径（从起点开始到该节点）标记为搜索的node的最短路径+1
    - 这样保证是最短的，因为bfs每一层都加1，每个节点到其邻接节点的最短距离为1，一层层传下去
    - 然后将其前驱节点修改为搜索的node
    - 最后将其修改为已访问
    - 后续通过其他节点回来的距离必然更大，因为bfs一层一层往下，先push进队列的都是更靠近起点的
  - 直到离开循环，所有节点到起点的最短路径都得到了标记
- 具体代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<vector<int>> graph{
        {1, 1, 1, 0, 0, 0, 0},
        {1, 1, 0, 1, 0, 0, 0},
        {1, 0, 1, 1, 1, 1, 0},
        {0, 1, 1, 1, 1 ,0 ,0},
        {0, 0, 1, 1, 1, 1, 0},
        {0, 0, 1, 0, 1, 1, 1},
        {0, 0, 0, 0, 0, 1, 1}
    };
    int n = graph.size();
    vector<vector<int>> stat(n, vector<int>{-1, -1, 0});
    stat[0][0] = 0, stat[0][2] = 1;

    queue<int> q;
    q.push(0);
    while(!q.empty()){
        int node = q.front();
        q.pop();
        for(int i = 0; i < graph[node].size(); i++){
            if(graph[node][i] && !stat[i][2]){
                stat[i][0] = stat[node][0] + 1;
                stat[i][1] = node;
                stat[i][2] = 1;
                q.push(i);
            }
        }
    }
    cout << stat[n - 1][0] << endl;
}
```



### Dijkstra算法

![image](https://user-images.githubusercontent.com/106053649/180816442-8be85318-9f9b-4ce6-ab75-e47f8e9dbf24.png)



- 具体流程如上图右所示，同bfs区别在于其有权
- 将本身权值设为0，不邻接的权值设为INT_MAX（其他方式也可）
- 首先也是对起始点进行初始化，与bfs不同的是需要将其直接连接的节点的最短路径与前驱节点进行更新
- 进行节点数-1次while循环，因为少了一个初始节点
- 每一次循环都将当前未访问节点中的路径最短的节点作为基准，遍历其直接相连的节点，更新这些节点的最短路径与前驱节点
- 直到所有节点都进行了上述流程，也就是n-1次循环后退出while
- 代码如下所示：

```c++
#include <bits/stdc++.h>
#include <cmath>
using namespace std;


int main(){
    vector<vector<int>> nums{{0, 5, INT_MAX, 10, INT_MAX, INT_MAX},
                             {5, 0, 2, 4, 9, INT_MAX},
                             {8, 2, 0, INT_MAX, 3, 6}, 
                             {10, 4, INT_MAX, 0, 2, INT_MAX}, 
                             {INT_MAX, 9, 3, 2, 0, 2}, 
                             {INT_MAX, INT_MAX, 6, INT_MAX, 2, 0}};
    int nodeNum = nums.size();
    vector<vector<int>> stat(nodeNum, vector<int>{INT_MAX, -1, 0});
    for(int i = 0; i < nums[0].size(); i++){
        if(nums[0][i] != INT_MAX){
            stat[i][0] = nums[0][i];
            stat[i][1] = 0;
        }
    }
    stat[0][2] = 1;
    int n = nodeNum;
    while(--n){
        sort(stat.begin(), stat.end());
        int i = 0;
        for(; i < nodeNum; i++){
            if(stat[i][2]){
                continue;
            }
            break;
        }
        for(int j = 1; j < nums[i].size(); j++){
            if(nums[i][j] != INT_MAX){
                if(stat[i][0] + nums[i][j] < stat[j][0]){
                    stat[j][0] = stat[i][0] + nums[i][j];
                    stat[j][1] = i;
                }
            }
        }
        stat[i][2] = 1;
    }
    cout<<stat[5][0]<<endl;
}
```



#### 例题

**Leetcode882**

- 上述的Dijkstra是我个人理解的版本，并不完全规范，且根据实际情况可以有改动
  - 不需要求路径可以不用存前驱节点的信息
  - 邻接表有时候比邻接矩阵更适合（少一些无用信息）
  - 是否已访问，可以通过当前节点的最短距离（从起点出发）是否等于初始化距离（是否更改过）来判断

- 在例题中，我使用优先队列（更方便判断当前最小距离节点）进行查询，使用邻接表存储连接信息
- 思路是先求得从0出发到其他所有点的单源最短路径，在去细分节点
- 注意优先队列默认是大根堆，根据需求需要传入functor

```c++
class Solution {
public:
    struct cmp{
        bool operator()(pair<int, int>& a, pair<int, int>& b){
            return a.first > b.first;
        }
    };
    int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
        vector<vector<pair<int, int>>> matrix(n);
        for(auto edge : edges){
            matrix[edge[0]].push_back({edge[1], edge[2] + 1});
            matrix[edge[1]].push_back({edge[0], edge[2] + 1});
        }
        vector<vector<int>> stat(n, vector<int>{INT_MAX, -1, 0});
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> pq;
        stat[0][0] = 0;
        pq.push({stat[0][0], 0});
        while(!pq.empty()){
            auto [dist, node] = pq.top();
            pq.pop();
            if(stat[node][2]){
                continue;
            } 
            stat[node][2] = 1;
            for(auto P : matrix[node]){
                if(dist + P.second < stat[P.first][0]){
                    stat[P.first][0] = dist + P.second;
                    pq.push({stat[P.first][0], P.first});
                    stat[P.first][1] = node;
                }
            }
        }
        int res = 0;
        vector<int> visited(n, 0);
        visited[0] = 1;
        // 记录每个边除去端点之外的点的访问量
        for (auto& e : edges) {
            int i = e[0];
            int j = e[1];
            int d = e[2];
            if (stat[i][0] <= maxMoves) visited[i] = 1;
            if (stat[j][0] <= maxMoves) visited[j] = 1;
            res += min(max(maxMoves - stat[i][0], 0) + max(maxMoves - stat[j][0], 0), d);
        }
        // 加上端点的访问量
        res += accumulate(visited.begin(), visited.end(), 0);
        return res;
    }
};
```



### Floyd算法

![image](https://user-images.githubusercontent.com/106053649/180816510-45200ee7-d3ac-4e39-ba4f-2723bca58ce8.png)

- 算法的本质就是不断加入中转节点，更新最短路径矩阵以及中转节点矩阵
- 能求得所有可达节点对之间的最短路径（Dijkstra需要对每个节点单独跑一次算法，需要跑n次）
- 代码其实很简单，就是三次for循环，最外层即为每次加入的中转节点，若加入中转后距离变短则修改两个矩阵

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<vector<int>> graph{{0, 999, 1, 999, 10},
                              {999, 0, 999, 1, 5},
                              {999, 1, 0, 999, 7},
                              {999, 999, 999, 0, 1},
                              {999, 999, 999, 999, 0}};
    int n = graph.size();
    vector<vector<int>> passNode(n, vector<int>(n, -1));
    for(int idx = 0; idx < n; idx++){
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(graph[i][idx] + graph[idx][j] < graph[i][j]){
                    graph[i][j] = graph[i][idx] + graph[idx][j];
                    passNode[i][j] = idx;
                }
            }
        }
    }
    for(auto a : graph){
        for(auto b : a){
            cout << b << " ";
        }
        cout << endl;
    }
}
```



### 小结

- bfs算法适用于求无权图的单源最短路径（一个节点出发到其他所有节点的最短路径）
- Dijkstra算法适用于求无权及带权图（不能为负）的单源及多源最短路径
  - 单源最短路径即跑一次算法流程（求得一个节点到其他所有节点的最短路径）
  - 多源即跑n次算法流程（求得每个顶点到其他所有节点的最短路径）
- Floyd算法适用于无权及带权图（负数也可）的最短路径（跑一次算法求得任意节点到其他所有节点的最短路径）